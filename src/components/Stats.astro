---
const stats = [
  {
    value: 300,
    suffix: "+",
    label: "Personnes formées"
  },
  {
    value: 100,
    suffix: "+",
    label: "Entreprises accompagnées"
  },
  {
    value: 2000,
    suffix: "+",
    label: "Heures économisées",
    format: true
  }
];
---

<section class="py-6 bg-gradient-to-b from-white to-zinc-50/50 lg:hidden stats-section">
  <div class="max-w-sm mx-auto px-6 flex flex-col gap-3">
    {stats.map((stat) => (
      <div class="flex items-center justify-between py-3 border-b border-zinc-100 last:border-0 stat-row">
        <span class="fluid-text-xs text-zinc-500 uppercase">{stat.label}</span>
        <span
          class="fluid-h5 font-semibold text-zinc-900 stat-counter-mobile"
          data-target={stat.value}
          data-suffix={stat.suffix}
          data-format={stat.format ? "true" : "false"}
        >
          0{stat.suffix}
        </span>
      </div>
    ))}
  </div>
</section>

<style>
  .stats-section {
    position: relative;
  }

  .stat-row {
    opacity: 0;
    transform: translateX(-10px);
    animation: stat-slide-in 0.5s ease-out forwards;
  }

  .stat-row:nth-child(1) { animation-delay: 0.1s; }
  .stat-row:nth-child(2) { animation-delay: 0.2s; }
  .stat-row:nth-child(3) { animation-delay: 0.3s; }

  @keyframes stat-slide-in {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
</style>

<script>
  // Counter animation for mobile stats
  const animateCounter = (element: HTMLElement) => {
    const target = parseInt(element.dataset.target || '0');
    const suffix = element.dataset.suffix || '';
    const shouldFormat = element.dataset.format === 'true';
    const duration = 1500;
    const startTime = performance.now();

    const updateCounter = (currentTime: number) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      const easeOut = 1 - Math.pow(1 - progress, 3);
      const current = Math.floor(easeOut * target);

      const formatted = shouldFormat
        ? current.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ')
        : current.toString();

      element.textContent = formatted + suffix;

      if (progress < 1) {
        requestAnimationFrame(updateCounter);
      }
    };

    requestAnimationFrame(updateCounter);
  };

  // Use IntersectionObserver for reliable detection
  const initCounters = () => {
    const counters = document.querySelectorAll('.stat-counter-mobile');

    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !entry.target.classList.contains('animated')) {
            entry.target.classList.add('animated');
            animateCounter(entry.target as HTMLElement);
          }
        });
      }, { threshold: 0.1 });

      counters.forEach(counter => observer.observe(counter));
    } else {
      // Fallback for older browsers
      counters.forEach(counter => {
        counter.classList.add('animated');
        animateCounter(counter as HTMLElement);
      });
    }
  };

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCounters);
  } else {
    initCounters();
  }
</script>
